<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Adam Soliev</title>
  <link href="https://fonts.googleapis.com/css2?family=David+Libre:wght@400;500;700&display=swap" rel="stylesheet">
  <link href="../style.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?lang=css&amp;skin=sons-of-obsidian"></script>
</head>
<body class="david-libre-regular">

<h1>Structure and Interpretation of Computer Programs (SICP)</h1>
<p>A biblesque book in CS circles that didn't quite live up to its reputation for me ¯\_(ツ)_/¯.</p>

<h2>Building Abstractions with Procedures</h2>
<h3>1. Elements of Programming</h3>
<ul>
  <li>Simplest entities the language is concerned with (e.g., basic types, operations and variables in Python)</li>
  <li>Key insight: Complex abstractions can be built from simple building blocks (primitives, means of combination and means of abstraction)</li>
</ul>

<h3>2. Procedures and Processes They Generate</h3>
<ul>
  <li>The same result can be achieved through different processes (recursive vs iterative), even when the procedures look similar</li>
  <li>Key insight: You need to understand both procedure (function) and its resulting process</li>
</ul>

<h3>3. Higher-Order Procedures</h3>
<ul>
  <li>Procedures can take in procedures or return them</li>
  <li>Key insight: You have a powerful tool to abstract common patterns directly in code</li>
</ul>
<pre><code class="prettyprint">
    # 
    # Procedure taking in a procedure as an argument
    # 
    def apply_function(func, value):
        return func(value)

    result = apply_function(lambda x: x * 2, 10)  # Returns 20

    # 
    # Procedure returning a procedure
    # 
    def make_multiplier(factor):
        def multiplier(x):
            return x * factor
        return multiplier

    double = make_multiplier(2)
    result = double(5)  # Returns 10
</code></pre>

<h2>Data Abstraction</h2>
<h3>4. Hierarchical Data</h3>
<ul>
  <li>Create compound elements that can themselves contain other compound elements</li>
  <li>Elements that can be defined in terms of themselves</li>
  <li>Clear separation between how data is used and how it's represented</li>
  <li>Key insight: Complex data abstractions can be built from simple data building blocks</li>
</ul>

<h3>5. Symbolic Data</h3>
<ul>
  <li>Non-numerical data (e.g., strings in Python)</li>
  <li>Key insight: You can work with and manipulate symbols and their abstractions</li>
</ul>
<pre><code class="prettyprint">
    # Representing algebraic expressions symbolically
    class Symbol:
        def __init__(self, name):
            self.name = name
        
        def __str__(self):
            return self.name

    class Expression:
        def __init__(self, operator, operands):
            self.operator = operator
            self.operands = operands
        
        def __str__(self):
            return f"({self.operator} {' '.join(map(str, self.operands))})"

    # Creating symbolic mathematical expressions
    x = Symbol('x')
    y = Symbol('y')
    expression = Expression('+', [x, Expression('*', [y, y])])
    # Represents: (+ x (* y y))
</code></pre>

<h3>6. Multiple Representations</h3>
<ul>
  <li>Key insight: The same abstract data can be represented in different ways while maintaining the same interface</li>
</ul>

<h3>7. Generic Operations</h3>
<ul>
  <li>Key insight: You can have operations that can work with different types of data using a common interface</li>
</ul>
<pre><code class="prettyprint">
    # Generic addition that works with different number types
    def add(x, y):
        # Dispatches to appropriate implementation based on type
        if is_complex(x) and is_complex(y):
            return add_complex(x, y)
        elif is_rational(x) and is_rational(y):
            return add_rational(x, y)
        else:
            return x + y  # Regular number addition
</code></pre>

<h2>Advanced Topics</h2>
<h3>8. Modularity and State Management</h3>
<ul>
  <li>State should be managed through well-defined interfaces</li>
  <li>Different aspects of state management should be handled by different modules</li>
  <li>Modules should be independent and reusable</li>
</ul>

<h3>9. Metalinguistic Abstraction</h3>
<ul>
  <li>Key insight: One can create higher-level abstractions on top of existing languages (e.g., DatabaseQuery class on top of Python) to make specific types of problems easier to solve</li>
</ul>
<pre><code class="prettyprint">
    # Instead of working directly with low-level constructs
    class DatabaseQuery:
        def __init__(self):
            self.conditions = []
        
        def where(self, condition):
            self.conditions.append(condition)
            return self
        
        def execute(self):
            # Convert high-level query to SQL
            return f"SELECT * FROM table WHERE {' AND '.join(self.conditions)}"

    # Creating a more natural language for queries
    query = (DatabaseQuery()
            .where("age > 18")
            .where("status = 'active'"))
</code></pre>

<h3>10. Register Machines</h3>
<ul>
  <li>A model of computation with registers to get data from and store data to and computation unit to do calculations</li>
</ul>

<h2>Contact</h2>
<ul>
  <li><a href="https://x.com/adamsoliev" target="_blank">@adamsoliev</a> on Twitter/X</li>
  <li><a href="https://github.com/adamsoliev" target="_blank">@adamsoliev</a> on Github</li>
  <li><a href="mailto:adamsoliev.se@gmail.com" target="_blank">adamsoliev.se@gmail.com</a> via email</li>
</ul>

</body>
</html>
