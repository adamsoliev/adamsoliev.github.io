<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Adam Soliev</title>
  <link href="https://fonts.googleapis.com/css2?family=David+Libre:wght@400;500;700&display=swap" rel="stylesheet">
  <link href="../style.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?lang=css&amp;skin=sons-of-obsidian"></script>
</head>
<body class="david-libre-regular">

<h2>Structure and Interpretation of Computer Programs (SICP)</h2>
<hr>
<p>The language used in the book is Lisp, which is unusual in a sense that it almost doesn't have any syntax and hence doesn't force a programmer to think in a certain way (e.g., absence of for-loops frees you from thinking in for-loops).</p>

<h3>Building Abstractions with Procedures</h3>
<p>Insight here is that functions can be treated as first-class citizens and can be passed around as values and returned from other functions. This allows one to address problems ranging from basic to fairly complex with just one abstraction - defining functions.</p>
<pre><code class="prettyprint">
    # 
    # Procedure taking in a procedure as an argument
    # 
    def apply_function(func, value):
        return func(value)

    result = apply_function(lambda x: x * 2, 10)  # Returns 20

    # 
    # Procedure returning a procedure
    # 
    def make_multiplier(factor):
        def multiplier(x):
            return x * factor
        return multiplier

    double = make_multiplier(2)
    result = double(5)  # Returns 10
    # 
    # You can imagine the above continuing further and further
    # 
</code></pre>

<h3>Building Abstractions with Data</h3>
<p>Insight here is that you can create compound elements that can themselves contain other compound elements. This allows you to build complex data abstractions from simple data building blocks.</p>

<h3>Modularity, Objects and State</h3>
<p>Combine these with above abstractions and you can build a Lisp evaluator, which determines the meaning of expressions in the language. You then realize that the evaluator is JUST another program. Applied to us, we aren't merely a user of a language designed by others, but a designer of languages.</p>

<h3>Register Machines</h3>
<p>While previous chapters show potential abstractions and how they can be used to build themselves, this chapter "looks 'under the hood' of Lisp itself to consider how it can be implemented with elements simpler than itself" <a href="https://www.lesswrong.com/posts/GAqCiWJBttazYGsJR/review-structure-and-interpretation-of-computer-programs" target="_blank">[1]</a> - a simple register machine.</p>

<h2>Contact</h2>
<ul>
  <li><a href="https://x.com/adamsoliev" target="_blank">@adamsoliev</a> on Twitter/X</li>
  <li><a href="https://github.com/adamsoliev" target="_blank">@adamsoliev</a> on Github</li>
  <li><a href="mailto:adamsoliev.se@gmail.com" target="_blank">adamsoliev.se@gmail.com</a> via email</li>
</ul>

</body>
</html>
